<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · BrandtSolver.jl</title><meta name="title" content="API Reference · BrandtSolver.jl"/><meta property="og:title" content="API Reference · BrandtSolver.jl"/><meta property="twitter:title" content="API Reference · BrandtSolver.jl"/><meta name="description" content="Documentation for BrandtSolver.jl."/><meta property="og:description" content="Documentation for BrandtSolver.jl."/><meta property="twitter:description" content="Documentation for BrandtSolver.jl."/><meta property="og:url" content="https://sliemelela.github.io/BrandtSolver.jl/api/"/><meta property="twitter:url" content="https://sliemelela.github.io/BrandtSolver.jl/api/"/><link rel="canonical" href="https://sliemelela.github.io/BrandtSolver.jl/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BrandtSolver.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../architecture/">Internal Architecture</a></li><li class="is-active"><a class="tocitem" href>API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/sliemelela/BrandtSolver.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Test"><a class="docs-heading-anchor" href="#Test">Test</a><a id="Test-1"></a><a class="docs-heading-anchor-permalink" href="#Test" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="BrandtSolver.AssetSV"><a class="docstring-binding" href="#BrandtSolver.AssetSV"><code>BrandtSolver.AssetSV</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Static Vector of size <code>(N,)</code> representing <code>N</code> assets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sliemelela/BrandtSolver.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BrandtSolver.AssetVec"><a class="docstring-binding" href="#BrandtSolver.AssetVec"><code>BrandtSolver.AssetVec</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Vector of size <code>(N,)</code> representing values across <code>N</code> assets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sliemelela/BrandtSolver.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BrandtSolver.RegressionStrategy"><a class="docstring-binding" href="#BrandtSolver.RegressionStrategy"><code>BrandtSolver.RegressionStrategy</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Abstract parent type for all regression strategies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sliemelela/BrandtSolver.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BrandtSolver.SimAssetMat"><a class="docstring-binding" href="#BrandtSolver.SimAssetMat"><code>BrandtSolver.SimAssetMat</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Matrix of size <code>(sim x N)</code> representing asset values for each simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sliemelela/BrandtSolver.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BrandtSolver.SimTimeMat"><a class="docstring-binding" href="#BrandtSolver.SimTimeMat"><code>BrandtSolver.SimTimeMat</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Matrix of size <code>(sim x Time)</code> representing scalar values over time for each simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sliemelela/BrandtSolver.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BrandtSolver.SimTimeSV"><a class="docstring-binding" href="#BrandtSolver.SimTimeSV"><code>BrandtSolver.SimTimeSV</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Matrix of size <code>(Sims x Time)</code> where each entry is an <code>AssetSV</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sliemelela/BrandtSolver.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BrandtSolver.SimVec"><a class="docstring-binding" href="#BrandtSolver.SimVec"><code>BrandtSolver.SimVec</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Vector of size <code>(sim,)</code> representing values across simulations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sliemelela/BrandtSolver.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BrandtSolver.SolverParams"><a class="docstring-binding" href="#BrandtSolver.SolverParams"><code>BrandtSolver.SolverParams</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct SolverParams</code></pre><p>Configuration parameters for the Brandt portfolio solver.</p><p><strong>Arguments</strong></p><ul><li><p><code>W_grid::Vector{Float64}</code>: Grid of wealth values at initial time t=0 used to evaluate and interpolate the policy function.</p></li><li><p><code>poly_order::Int64</code>: Order of the polynomial used for expanding state variables in the cross-sectional regression.</p></li><li><p><code>max_taylor_order::Int64</code>: The truncation order for the Taylor expansion of the value function.</p></li><li><p><code>trimming_α::Float64</code>: The α value used if a trimmed regression strategy is applied.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sliemelela/BrandtSolver.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BrandtSolver.StandardOLS"><a class="docstring-binding" href="#BrandtSolver.StandardOLS"><code>BrandtSolver.StandardOLS</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Standard Ordinary Least Squares. Fastest method. Uses QR factorization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sliemelela/BrandtSolver.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BrandtSolver.TrimmedOLS"><a class="docstring-binding" href="#BrandtSolver.TrimmedOLS"><code>BrandtSolver.TrimmedOLS</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Trimmed OLS (robust to outliers). Removes the top and bottom α probability mass before regressing.</p><p><strong>Arguments</strong></p><ul><li><code>α::Float64</code>: The fraction of data to trim from both tails (e.g., 0.05 for 5% trimming).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sliemelela/BrandtSolver.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BrandtSolver.UtilityFunctions"><a class="docstring-binding" href="#BrandtSolver.UtilityFunctions"><code>BrandtSolver.UtilityFunctions</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct UtilityFunctions</code></pre><p>A container for the utility function, its derivatives, and its inverse.</p><p><strong>Arguments</strong></p><ul><li><p><code>u::Function</code>: The base utility function <code>U(W)</code>.</p></li><li><p><code>nth_derivative::Function</code>: A function <code>f(n)</code> that returns a function for the <code>n</code>-th derivative of <code>U(W)</code>.</p></li><li><p><code>inverse::Function</code>: The inverse utility function, used to calculate Certainty Equivalents.</p></li></ul><p>Typically, you do not construct this manually. Instead, use <a href="#BrandtSolver.create_utility_from_ad-Tuple{Function}"><code>create_utility_from_ad</code></a> to generate it automatically from a base utility function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sliemelela/BrandtSolver.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BrandtSolver.calculate_expected_utility-Tuple{AbstractMatrix{&lt;:StaticArraysCore.SVector}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Vector{Vector{Any}}, Int64, Float64, Union{Vector{&lt;:StaticArraysCore.SVector}, StaticArraysCore.SVector}, UtilityFunctions}"><a class="docstring-binding" href="#BrandtSolver.calculate_expected_utility-Tuple{AbstractMatrix{&lt;:StaticArraysCore.SVector}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Vector{Vector{Any}}, Int64, Float64, Union{Vector{&lt;:StaticArraysCore.SVector}, StaticArraysCore.SVector}, UtilityFunctions}"><code>BrandtSolver.calculate_expected_utility</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calculate_expected_utility(
    Re_all_paths::AbstractMatrix{&lt;:SVector},
    X_all_paths::AbstractMatrix{Float64},
    Y_all_paths::AbstractMatrix{Float64},
    future_policies::Vector{Vector{Any}},
    t_start::Int,
    W_start::Float64,
    ω_force::Union{Vector{&lt;:SVector}, &lt;:SVector},
    utility_struct::UtilityFunctions
)</code></pre><p>Evaluates the expected utility and Certainty Equivalent (CE) of a specific portfolio allocation (<code>ω_force</code>) at time <code>t_start</code> for a given starting wealth (<code>W_start</code>).</p><p>It calculates this by forward-simulating the wealth trajectories from <code>t_start</code> to terminal time <code>T</code>, assuming the agent applies the forced weights at <code>t_start</code> and then follows the optimal <code>future_policies</code> for all subsequent periods.</p><p>Paths that result in bankruptcy (wealth <span>$\leq 10^{-9}$</span>) are filtered out to prevent numerical explosion (e.g., utility approaching <span>$-\infty$</span> for CRRA) before computing the final mean.</p><p><strong>Arguments</strong></p><ul><li><code>Re_all_paths::AbstractMatrix{&lt;:SVector}</code>: A matrix <code>(sims × steps)</code> of <code>SVector</code>s representing excess returns.</li><li><code>X_all_paths::AbstractMatrix{Float64}</code>: A matrix <code>(sims × steps)</code> of gross risk-free returns.</li><li><code>Y_all_paths::AbstractMatrix{Float64}</code>: A matrix <code>(sims × steps)</code> of non-tradable income yields.</li><li><code>future_policies::Vector{Vector{Any}}</code>: A nested vector structure containing the   interpolated policy rules for <span>$t &gt; t_{start}$</span>.</li><li><code>t_start::Int</code>: The time step from which to begin the forward simulation.</li><li><code>W_start::Float64</code>: The starting wealth level applied uniformly across all simulation paths.</li><li><code>ω_force::Union{Vector{&lt;:SVector}, &lt;:SVector}</code>: The portfolio allocation to force at <code>t_start</code>.   Can be a single <code>SVector</code> (applied to all paths) or a <code>Vector</code> of <code>SVector</code>s (path-dependent weights).</li><li><code>utility_struct::UtilityFunctions</code>: The configured <code>UtilityFunctions</code> containing the base   utility <code>u</code> and its <code>inverse</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A tuple <code>(J_0, CE_0)</code>:<ul><li><code>J_0::Float64</code>: The conditionally expected utility across all valid, non-bankrupt simulated paths.</li><li><code>CE_0::Float64</code>: The Certainty Equivalent of that expected utility (the guaranteed, risk-free wealth level that yields identical utility).</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sliemelela/BrandtSolver.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BrandtSolver.calculate_next_wealth-NTuple{4, Any}"><a class="docstring-binding" href="#BrandtSolver.calculate_next_wealth-NTuple{4, Any}"><code>BrandtSolver.calculate_next_wealth</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs"> calculate_next_wealth(W_current, ω_t, Re_next, R_free)</code></pre><p>The core physics kernel that advances wealth...</p><p><strong>Arguments</strong></p><ul><li><code>W_current</code>: The wealth at time <span>$t$</span>.</li><li><code>ω_t</code>: The chosen portfolio weight(s) for the risky assets at time <span>$t$</span>.</li><li><code>Re_next</code>: The realized excess return(s) of the risky assets at time <span>$t+1$</span>.</li><li><code>R_free</code>: The gross risk-free return between <span>$t$</span> and <span>$t+1$</span>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sliemelela/BrandtSolver.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BrandtSolver.calculate_realized_term-Tuple{Int64, Vector{Int64}, Vector{Float64}, Vector{Float64}, AbstractVector{&lt;:StaticArraysCore.SVector}, UtilityFunctions}"><a class="docstring-binding" href="#BrandtSolver.calculate_realized_term-Tuple{Int64, Vector{Int64}, Vector{Float64}, Vector{Float64}, AbstractVector{&lt;:StaticArraysCore.SVector}, UtilityFunctions}"><code>BrandtSolver.calculate_realized_term</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calculate_realized_term(
    n::Int,
    k_vec::Vector{Int},
    W_t_plus_1::Vector{Float64},
    W_T::Vector{Float64},
    Re_next_svec::AbstractVector{&lt;:SVector},
    utility::UtilityFunctions,
)</code></pre><p>Computes the realized marginal utility integrand (<span>$Y_n$</span>) for the <span>$n$</span>-th order term of the Taylor-expanded equation across all simulation paths.</p><p>The realized integrand for the Taylor expansion evaluates to: <code>math     Y_n = U^{(n)}(W_T) \left(\frac{W_T}{W_{t+1}}\right)^n \left(\prod_{j=1}^{N} R_{e, j, t+1}^{k_j}\right) R_{e, t+1}</code>`</p><p><strong>Arguments</strong></p><ul><li><code>n::Int</code>: The specific derivative order in the Taylor expansion (e.g., 2 for the variance term).</li><li><code>k_vec::Vector{Int}</code>: A vector of integers representing the cross-asset monomial exponents <span>$k_j$</span> for the multivariate expansion.</li><li><code>W_t_plus_1::Vector{Float64}</code>: Simulated wealth at time <span>$t+1$</span>.</li><li><code>W_T::Vector{Float64}</code>: Simulated terminal wealth at time <span>$T$</span>.</li><li><code>Re_next_svec::AbstractVector{&lt;:SVector}</code>: A vector of <code>SVector</code> excess returns at time <span>$t+1$</span>.</li><li><code>utility::UtilityFunctions</code>: The <code>UtilityFunctions</code> struct containing the <span>$n$</span>-th derivative generator.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Matrix{Float64}</code> of size <code>(sims × N_assets)</code> containing the evaluated integrand for each simulation path and each asset.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sliemelela/BrandtSolver.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BrandtSolver.compute_and_regress_moments-Tuple{Int64, Int64, Int64, Vector{&lt;:AbstractMatrix{Float64}}, Vector{Float64}, Vector{Float64}, AbstractVector{&lt;:StaticArraysCore.SVector}, UtilityFunctions, BrandtSolver.RegressionStrategy}"><a class="docstring-binding" href="#BrandtSolver.compute_and_regress_moments-Tuple{Int64, Int64, Int64, Vector{&lt;:AbstractMatrix{Float64}}, Vector{Float64}, Vector{Float64}, AbstractVector{&lt;:StaticArraysCore.SVector}, UtilityFunctions, BrandtSolver.RegressionStrategy}"><code>BrandtSolver.compute_and_regress_moments</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_and_regress_moments(t_decision, poly_order, max_taylor_order, Z_all_paths, W_t_plus_1,
    W_T, Re_next_svec, utility, reg_strategy)</code></pre><p>Orchestrates the calculation of conditionally expected marginal utility moments for the Taylor-expanded equation.</p><p>For each term in the Taylor expansion up to <code>max_taylor_order</code> and for all cross-asset combinations (generated via <code>multiexponents</code>), this function calculates the realized ex-post integrand and then projects it onto the space of available information at <code>t_decision</code> using a cross-sectional regression.</p><p><strong>Arguments</strong></p><ul><li><code>t_decision::Int</code>: The current time step in the backward recursion.</li><li><code>poly_order::Int</code>: The polynomial degree used to construct the basis functions (design matrix) from the state variables.</li><li><code>max_taylor_order::Int</code>: The highest order of the Taylor expansion to compute.</li><li><code>Z_all_paths::Vector{&lt;:AbstractMatrix{Float64}}</code>: A vector containing the full simulated paths of all state variables.</li><li><code>W_t_plus_1::Vector{Float64}</code>: The simulated wealth across all paths at time <span>$t+1$</span>.</li><li><code>W_T::Vector{Float64}</code>: The simulated terminal wealth across all paths at time <span>$T$</span>.</li><li><code>Re_next_svec::AbstractVector{&lt;:SVector}</code>: A vector of <code>SVector</code>s representing realized excess returns at time <span>$t+1$</span>.</li><li><code>utility::UtilityFunctions</code>: The configured utility container with automatic differentiation.</li><li><code>reg_strategy::RegressionStrategy</code>: The chosen regression strategy (e.g., <code>StandardOLS</code> or <code>TrimmedOLS</code>).</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{Vector{Int}, Matrix{Float64}}</code>: A dictionary mapping the cross-asset monomial exponent   vectors (<code>k_vec</code>) to their conditionally expected values (a <code>sims × N_assets</code> matrix).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sliemelela/BrandtSolver.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BrandtSolver.compute_conditional_expectation-Tuple{Int64, BrandtSolver.RegressionStrategy, Any, Union{Nothing, AbstractMatrix{Float64}}, Matrix{Float64}}"><a class="docstring-binding" href="#BrandtSolver.compute_conditional_expectation-Tuple{Int64, BrandtSolver.RegressionStrategy, Any, Union{Nothing, AbstractMatrix{Float64}}, Matrix{Float64}}"><code>BrandtSolver.compute_conditional_expectation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_conditional_expectation(t_decision, reg_strategy, reg_context, φ, integrand)</code></pre><p>Performs the cross-sectional regression to map realized future quantities to present expectations, conditional on current state variables.</p><p>At <span>$t &gt; 1$</span>, it uses the pre-computed regression context (e.g., a QR factorization) to rapidly project the realized <code>integrand</code> onto the basis matrix <code>φ</code>. At <span>$t = 1$</span>, since all agents share the exact same starting state, the conditional expectation is mathematically identical to the unconditional cross-sectional mean.</p><p><strong>Arguments</strong></p><ul><li><code>t_decision::Int</code>: The current time step.</li><li><code>reg_strategy::RegressionStrategy</code>: The specific algorithm used to estimate coefficients.</li><li><code>reg_context::Any</code>: The pre-computed regression context   (e.g., a <code>Factorization</code> object for <code>StandardOLS</code> or a raw matrix for <code>TrimmedOLS</code>).</li><li><code>φ::Union{Nothing, AbstractMatrix{Float64}}</code>: The polynomial expansion of the state variables   (design matrix). Will be <code>nothing</code> at <span>$t = 1$</span>.</li><li><code>integrand::Matrix{Float64}</code>: The realized future values (<span>$Y_n$</span>) to be projected onto the state space.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code>: The predicted (conditionally expected) values for each simulation path and each asset.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sliemelela/BrandtSolver.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BrandtSolver.compute_expectations_and_policy-Tuple{Int64, Int64, Int64, Float64, Vector{&lt;:AbstractMatrix{Float64}}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{&lt;:StaticArraysCore.SVector}, Int64, UtilityFunctions, Vector, BrandtSolver.RegressionStrategy}"><a class="docstring-binding" href="#BrandtSolver.compute_expectations_and_policy-Tuple{Int64, Int64, Int64, Float64, Vector{&lt;:AbstractMatrix{Float64}}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{&lt;:StaticArraysCore.SVector}, Int64, UtilityFunctions, Vector, BrandtSolver.RegressionStrategy}"><code>BrandtSolver.compute_expectations_and_policy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_expectations_and_policy(
    t_decision::Int,
    poly_order::Int,
    max_taylor_order::Int,
    W_at_t::Float64,
    Z_all_paths::Vector{&lt;:AbstractMatrix{Float64}},
    R_free_base::AbstractMatrix{Float64},
    income_component::AbstractMatrix{Float64},
    Re_all_paths::AbstractMatrix{&lt;:SVector},
    T_steps::Int,
    utility::UtilityFunctions,
    future_policies::Vector,
    reg_strategy::RegressionStrategy,
)</code></pre><p>Calculates the conditional expectations of utility moments and solves the First Order Conditions (FOCs) for the optimal portfolio weights across all simulation paths at a specific decision time and a <em>single</em> starting wealth level.</p><p><strong>Arguments</strong></p><ul><li><code>t_decision::Int</code>: The current time step in the backward recursion.</li><li><code>poly_order::Int</code>: The polynomial degree for the cross-sectional regression basis.</li><li><code>max_taylor_order::Int</code>: The Taylor expansion order of the value function.</li><li><code>W_at_t::Float64</code>: The specific wealth level being evaluated across all paths.</li><li><code>Z_all_paths::Vector{&lt;:AbstractMatrix{Float64}}</code>: A vector of matrices representing the state variables.</li><li><code>R_free_base::AbstractMatrix{Float64}</code>: A matrix of gross risk-free returns.</li><li><code>income_component::AbstractMatrix{Float64}</code>: A matrix of the non-tradable income yields.</li><li><code>Re_all_paths::AbstractMatrix{&lt;:SVector}</code>: A matrix of SVector excess returns for the risky assets.</li><li><code>T_steps::Int</code>: The total number of simulation time steps.</li><li><code>utility::UtilityFunctions</code>: The utility struct containing <code>u</code> and its derivatives.</li><li><code>future_policies::Vector</code>: The optimal policy interpolators for time periods <code>t &gt; t_decision</code>.</li><li><code>reg_strategy::RegressionStrategy</code>: The OLS strategy (Standard or Trimmed).</li></ul><p><strong>Returns</strong></p><ul><li><code>ω_t_svec</code>: A vector of <code>SVector</code>s containing the optimal weights for each simulation path.</li><li><code>expected_moments_all</code>: A dictionary mapping exponent vectors to their conditionally expected matrices.</li><li><code>W_t_plus_1</code>: The simulated wealth at the next time step.</li><li><code>W_T</code>: The simulated terminal wealth.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sliemelela/BrandtSolver.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BrandtSolver.create_policy_interpolators-Tuple{Int64, Vector{Float64}, Int64, Vector{&lt;:AbstractMatrix{Float64}}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{&lt;:StaticArraysCore.SVector}, Int64, UtilityFunctions, Vector{Vector{Any}}, Int64, BrandtSolver.RegressionStrategy, BrandtSolver.AbstractSolverRecorder}"><a class="docstring-binding" href="#BrandtSolver.create_policy_interpolators-Tuple{Int64, Vector{Float64}, Int64, Vector{&lt;:AbstractMatrix{Float64}}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{&lt;:StaticArraysCore.SVector}, Int64, UtilityFunctions, Vector{Vector{Any}}, Int64, BrandtSolver.RegressionStrategy, BrandtSolver.AbstractSolverRecorder}"><code>BrandtSolver.create_policy_interpolators</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_policy_interpolators(
    t_decision::Int,
    W_grid::Vector{Float64},
    poly_order::Int,
    Z_all_paths::Vector{&lt;:AbstractMatrix{Float64}},
    R_free_base::AbstractMatrix{Float64},
    income_component::AbstractMatrix{Float64},
    Re_all_paths::AbstractMatrix{&lt;:SVector},
    T_steps::Int,
    utility::UtilityFunctions,
    future_policies::Vector{Vector{Any}},
    max_taylor_order::Int,
    reg_strategy::RegressionStrategy,
    recorder::AbstractSolverRecorder
)</code></pre><p>Constructs state-contingent policy rules for a given decision time by evaluating optimal portfolio weights across a specified grid of wealth values (<code>W_grid</code>) and interpolating the results.</p><p><strong>Arguments</strong></p><ul><li><code>t_decision::Int</code>: Current time step in the backward recursion.</li><li><code>W_grid::Vector{Float64}</code>: The grid of wealth values to evaluate.</li><li><code>poly_order::Int</code>: Polynomial degree for the cross-sectional regression.</li><li><code>Z_all_paths::Vector{&lt;:AbstractMatrix{Float64}}</code>: Vector of state variable matrices.</li><li><code>R_free_base::AbstractMatrix{Float64}</code>: Gross risk-free return matrix.</li><li><code>income_component::AbstractMatrix{Float64}</code>: Non-tradable income matrix.</li><li><code>Re_all_paths::AbstractMatrix{&lt;:SVector}</code>: Matrix of <code>SVector</code> excess returns.</li><li><code>T_steps::Int</code>: Total number of time steps.</li><li><code>utility::UtilityFunctions</code>: The <code>UtilityFunctions</code> struct.</li><li><code>future_policies::Vector{Vector{Any}}</code>: A vector of previously computed future policies.</li><li><code>max_taylor_order::Int</code>: Expansion order for the Euler equation.</li><li><code>reg_strategy::RegressionStrategy</code>: The OLS strategy (Standard or Trimmed).</li><li><code>recorder::AbstractSolverRecorder</code>: The logging mechanism for debugging data.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Vector</code> of linear interpolation objects (one for each simulation path).   Each interpolator takes a wealth value <code>W</code> and returns the optimal portfolio allocation vector <code>ω</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sliemelela/BrandtSolver.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BrandtSolver.create_utility_from_ad-Tuple{Function}"><a class="docstring-binding" href="#BrandtSolver.create_utility_from_ad-Tuple{Function}"><code>BrandtSolver.create_utility_from_ad</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_utility_from_ad(base_utility_func::Function)</code></pre><p>Wraps a user-provided base utility function into a <a href="#BrandtSolver.UtilityFunctions"><code>UtilityFunctions</code></a> struct, automatically generating its exact higher-order derivatives and an inverse function.</p><p><strong>Details</strong></p><ul><li><strong>Derivatives:</strong> Uses <code>ForwardDiff.derivative</code> recursively to compute any <span>$n$</span>-th order derivative.   Results are aggressively cached in a closure dictionary so that re-evaluating the same   derivative order carries zero compilation or setup overhead.</li><li><strong>Inverse:</strong> Generates an inverse utility function <span>$W = U^{-1}(J)$</span> using Newton&#39;s method   (<code>Roots.find_zero</code>), relying on the automatically computed first derivative for fast convergence.</li></ul><p><strong>Arguments</strong></p><ul><li><code>base_utility_func::Function</code>: A standard scalar function representing utility,   e.g., <span>$W \mapsto \frac{W^{1-γ}}{1-γ}$</span></li></ul><p><strong>Returns</strong></p><ul><li>A populated <code>UtilityFunctions</code> struct.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sliemelela/BrandtSolver.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BrandtSolver.estimate_coefficients-Tuple{StandardOLS, LinearAlgebra.Factorization, AbstractVector{Float64}}"><a class="docstring-binding" href="#BrandtSolver.estimate_coefficients-Tuple{StandardOLS, LinearAlgebra.Factorization, AbstractVector{Float64}}"><code>BrandtSolver.estimate_coefficients</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_coefficients(::StandardOLS, qrΦ::Factorization, Y::AbstractVector{Float64})</code></pre><p>Estimates regression coefficients using Standard Ordinary Least Squares (OLS).</p><p>This method dispatches on the <code>StandardOLS</code> strategy type. It utilizes a pre-computed QR factorization (<code>qrΦ</code>) for maximum performance, avoiding the need to re-factorize the design matrix at every step.</p><p><strong>Arguments</strong></p><ul><li><code>::StandardOLS</code>: The strategy selector. The variable name is omitted (anonymous argument) because the struct contains no data needed for the calculation.</li><li><code>qrΦ::Factorization</code>: The QR factorization of the design matrix Φ (from <code>qr(Φ)</code>).</li><li><code>Y::AbstractVector{Float64}</code>: The dependent variable (response vector).</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: The estimated coefficients θ minimizing ||Φθ - Y||².</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sliemelela/BrandtSolver.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BrandtSolver.estimate_coefficients-Tuple{TrimmedOLS, AbstractMatrix, AbstractVector{Float64}}"><a class="docstring-binding" href="#BrandtSolver.estimate_coefficients-Tuple{TrimmedOLS, AbstractMatrix, AbstractVector{Float64}}"><code>BrandtSolver.estimate_coefficients</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_coefficients(strat::TrimmedOLS, Φ::AbstractMatrix, Y::AbstractVector{Float64})</code></pre><p>Estimates regression coefficients using α-Trimmed OLS (Least Trimmed Squares).</p><p>This method dispatches on the <code>TrimmedOLS</code> strategy. It is designed to be robust against outliers (e.g., extreme wealth paths in long-horizon simulations) by physically removing the top and bottom <code>α</code> fraction of the data distribution before regressing.</p><p><strong>Arguments</strong></p><ul><li><code>strategy::TrimmedOLS</code>: The strategy struct containing the trimming parameter <code>strat.alpha</code>.</li><li><code>Φ::AbstractMatrix</code>: The <strong>raw</strong> design matrix. <em>Note:</em> Unlike Standard OLS, we cannot use a pre-computed QR factorization because the rows included in the regression change dynamically based on the sorting of <code>Y</code>.</li><li><code>Y::AbstractVector{Float64}</code>: The dependent variable (response vector).</li></ul><p><strong>Algorithm</strong></p><ol><li>Calculates integer indices corresponding to the <code>α</code> and <code>1-α</code> quantiles.</li><li>Sorts <code>Y</code> to identify the &quot;body&quot; of the distribution.</li><li>Subsets both <code>Y</code> and <code>Φ</code> to exclude the extreme tails.</li><li>Solves standard OLS on the remaining subset.</li></ol><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: The estimated coefficients θ based on the trimmed dataset.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sliemelela/BrandtSolver.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BrandtSolver.plot_policy_rules-NTuple{4, Any}"><a class="docstring-binding" href="#BrandtSolver.plot_policy_rules-NTuple{4, Any}"><code>BrandtSolver.plot_policy_rules</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plot_policy_rules(future_policies, solver_params, t_idx, asset_names; samples=50)</code></pre><p>Plots the optimal portfolio allocation (weights) as a function of wealth (<span>$W$</span>) for a specific decision time <code>t_idx</code>.</p><p>It plots a subset of individual simulation paths to show cross-sectional dispersion (due to varying state variables) and overlays a thick red line representing the mean policy across all simulations.</p><p><strong>Arguments</strong></p><ul><li><code>future_policies</code>: The nested vector of interpolated policy functions returned by the solver.</li><li><code>solver_params</code>: The configuration parameters, specifically used to extract the <code>W_grid</code>.</li><li><code>t_idx</code>: The decision time step to evaluate.</li><li><code>asset_names</code>: A list of strings representing the asset names, used to generate subplots.</li><li><code>samples</code>: (Keyword) The number of individual simulation paths to plot as semi-transparent lines   (defaults to 50).</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Makie.Figure</code> object containing the generated plot.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sliemelela/BrandtSolver.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BrandtSolver.plot_policy_surface-Tuple{Any, Any, Any, AbstractVector, String, Any}"><a class="docstring-binding" href="#BrandtSolver.plot_policy_surface-Tuple{Any, Any, Any, AbstractVector, String, Any}"><code>BrandtSolver.plot_policy_surface</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plot_policy_surface(future_policies, solver_params, t_idx, state_values::AbstractVector, state_name::String, asset_names)</code></pre><p>Generates a 3D surface plot visualizing the optimal portfolio weight as a joint function of both Wealth (<span>$W$</span>) and a specific state variable at decision time <code>t_idx</code>.</p><p>This provides a comprehensive view of the agent&#39;s full policy rule, showing how intertemporal hedging demands (driven by the state variable) interact with risk aversion (driven by wealth).</p><p><strong>Arguments</strong></p><ul><li><code>future_policies</code>: The nested vector of interpolated policy functions.</li><li><code>solver_params</code>: The configuration parameters used to extract <code>W_grid</code>.</li><li><code>t_idx</code>: The decision time step to evaluate.</li><li><code>state_values</code>: A vector containing the cross-sectional values of the state variable at <code>t_idx</code>.</li><li><code>state_name</code>: A string label for the state variable used for the y-axis.</li><li><code>asset_names</code>: A list of strings representing the asset names.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Makie.Figure</code> object containing the generated 3D surface plot.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sliemelela/BrandtSolver.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BrandtSolver.plot_realized_weights-NTuple{6, Any}"><a class="docstring-binding" href="#BrandtSolver.plot_realized_weights-NTuple{6, Any}"><code>BrandtSolver.plot_realized_weights</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs"> plot_realized_weights(Re_all_paths, X_all_paths, Y_all_paths, times, future_policies,
    asset_names; W_init=100.0)</code></pre><p>Simulates wealth paths forward in time using the computed optimal <code>future_policies</code> and plots the realized trajectories of the portfolio weights over the lifecycle.</p><p>It overlays the mean realized weight and a 90% confidence interval band. Paths where wealth falls to zero (bankruptcy) are dynamically filtered out.</p><p><strong>Arguments</strong></p><ul><li><code>Re_all_paths</code>: A matrix <code>(sims × steps)</code> of <code>SVector</code>s representing excess returns.</li><li><code>X_all_paths</code>: A matrix <code>(sims × steps)</code> of gross risk-free returns.</li><li><code>Y_all_paths</code>: A matrix <code>(sims × steps)</code> of non-tradable income yields.</li><li><code>times</code>: An iterable of time points corresponding to the decision steps.</li><li><code>future_policies</code>: The nested vector of interpolated policy functions.</li><li><code>asset_names</code>: A list of strings representing the asset names.</li><li><code>W_init</code>: (Keyword) The initial wealth to start the forward simulation (defaults to 100.0).</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Makie.Figure</code> object containing the generated plot.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sliemelela/BrandtSolver.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BrandtSolver.plot_state_dependence-Tuple{Any, Any, Any, AbstractVector, String, Any}"><a class="docstring-binding" href="#BrandtSolver.plot_state_dependence-Tuple{Any, Any, Any, AbstractVector, String, Any}"><code>BrandtSolver.plot_state_dependence</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plot_state_dependence(future_policies, solver_params, t_idx, state_values::AbstractVector,
    state_name::String, asset_names; fix_W=100.0)</code></pre><p>Plots the sensitivity of the optimal portfolio weights to a specific state variable (e.g., interest rate or dividend yield), holding wealth strictly constant at <code>fix_W</code>.</p><p><strong>Arguments</strong></p><ul><li><code>future_policies</code>: The nested vector of interpolated policy functions.</li><li><code>solver_params</code>: The configuration parameters.</li><li><code>t_idx</code>: The decision time step to evaluate.</li><li><code>state_values</code>: A vector containing the cross-sectional values of the state variable at <code>t_idx</code>.</li><li><code>state_name</code>: A string label for the state variable used for the x-axis.</li><li><code>asset_names</code>: A list of strings representing the asset names.</li><li><code>fix_W</code>: (Keyword) The constant wealth level at which to evaluate the policy (defaults to 100.0).</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Makie.Figure</code> object containing the generated plot.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sliemelela/BrandtSolver.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BrandtSolver.plot_value_vs_utility-NTuple{6, Any}"><a class="docstring-binding" href="#BrandtSolver.plot_value_vs_utility-NTuple{6, Any}"><code>BrandtSolver.plot_value_vs_utility</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plot_value_vs_utility(Re_all_paths, X_all_paths, Y_all_paths, solver_params, future_policies,
    utility_struct; t_check=nothing)</code></pre><p>Serves as an economic validity check by plotting the forward-simulated expected utility (the Value function, <span>$J(W)$</span>) against the theoretical terminal utility function <span>$U(W)$</span>.</p><p>If the solver is working correctly, the expected utility <span>$J(W)$</span> evaluated at <span>$T - 1$</span> should be equal to <span>$U(W)$</span>, representing the value added by optimal dynamic trading.</p><p><strong>Arguments</strong></p><ul><li><code>Re_all_paths</code>: A matrix of <code>SVector</code>s representing excess returns.</li><li><code>X_all_paths</code>: A matrix of gross risk-free returns.</li><li><code>Y_all_paths</code>: A matrix of non-tradable income yields.</li><li><code>solver_params</code>: The configuration parameters used to extract <code>W_grid</code>.</li><li><code>future_policies</code>: The nested vector of interpolated policy functions.</li><li><code>utility_struct</code>: The utility container.</li><li><code>t_check</code>: (Keyword) The specific time step to evaluate. Defaults to <code>T-1</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Makie.Figure</code> object containing the generated plot.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sliemelela/BrandtSolver.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BrandtSolver.power_matrix-Tuple{Vector{Vector{Float64}}, Int64}"><a class="docstring-binding" href="#BrandtSolver.power_matrix-Tuple{Vector{Vector{Float64}}, Int64}"><code>BrandtSolver.power_matrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">power_matrix(Z::Vector{Vector{Float64}}, p::Int)</code></pre><p>Constructs a design matrix (feature matrix) for a polynomial regression model.</p><p>It generates power terms (e.g., x, x^2, ..., x^p) for each predictor variable in <code>Z</code> and prepends a column of ones to serve as the intercept term.</p><p>The final column order is: <code>[intercept, Z[1]^1, Z[1]^2, ..., Z[1]^p, Z[2]^1, Z[2]^2, ..., Z[2]^p, ...]</code></p><p><strong>Arguments</strong></p><ul><li><code>Z::Vector{Vector{Float64}}</code>: A vector of predictor variables. <code>n = length(Z)</code> is the number of distinct predictor variables, and <code>sim = length(Z[1])</code> is the number of observations (rows). All inner vectors must have the same length.</li><li><code>p::Int</code>: The maximum polynomial degree to compute for each predictor.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code>: A design matrix of size <code>sim × (n*p + 1)</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X1 = [1.0, 2.0, 3.0];

julia&gt; X2 = [4.0, 5.0, 6.0];

julia&gt; Z = [X1, X2]; # n=2 predictors, sim=3 observations

julia&gt; p = 2; # Max degree

julia&gt; BrandtSolver.power_matrix(Z, p)
3×5 Matrix{Float64}:
 1.0  1.0  1.0  4.0  16.0
 1.0  2.0  4.0  5.0  25.0
 1.0  3.0  9.0  6.0  36.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sliemelela/BrandtSolver.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BrandtSolver.record_step!-Tuple{DebugRecorder, Int64, Int64, Symbol, Any}"><a class="docstring-binding" href="#BrandtSolver.record_step!-Tuple{DebugRecorder, Int64, Int64, Symbol, Any}"><code>BrandtSolver.record_step!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">record_step!(recorder, t, w_idx, label, value)</code></pre><p>Hooks into the solver to save data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sliemelela/BrandtSolver.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BrandtSolver.simulate_wealth_trajectory-Tuple{Vector{Float64}, Int64, Int64, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{&lt;:StaticArraysCore.SVector}, Vector{Vector{Any}}}"><a class="docstring-binding" href="#BrandtSolver.simulate_wealth_trajectory-Tuple{Vector{Float64}, Int64, Int64, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{&lt;:StaticArraysCore.SVector}, Vector{Vector{Any}}}"><code>BrandtSolver.simulate_wealth_trajectory</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simulate_wealth_trajectory(
    W_start_vec::Vector{Float64},
    t_start_idx::Int,
    T_end_idx::Int,
    X_full::AbstractMatrix{Float64},
    Y_full::AbstractMatrix{Float64},
    Re_full::AbstractMatrix{&lt;:SVector},
    future_policies::Vector{Vector{Any}};
    forced_policy_at_t_start=nothing,
    recorder::AbstractPathRecorder = NoOpPathRecorder()
)</code></pre><p>Simulates wealth trajectories forward in time across all simulation paths from <code>t_start_idx</code> to <code>T_end_idx</code>.</p><p>At each time step, the function determines the portfolio weights (either using <code>forced_policy_at_t_start</code> for the initial step or querying the interpolated <code>future_policies</code> for subsequent steps). It then advances wealth using the <code>calculate_next_wealth</code> physics kernel.</p><p><strong>Arguments</strong></p><ul><li><code>W_start_vec::Vector{Float64}</code>: Initial wealth values for all simulation paths at <code>t_start_idx</code>.</li><li><code>t_start_idx::Int</code>: The starting time step index.</li><li><code>T_end_idx::Int</code>: The terminal time step index.</li><li><code>X_full::AbstractMatrix{Float64}</code>: Abstract matrix <code>(sims × steps)</code> of gross risk-free returns.</li><li><code>Y_full::AbstractMatrix{Float64}</code>: Abstract matrix <code>(sims × steps)</code> of non-tradable income yields.</li><li><code>Re_full::AbstractMatrix{&lt;:SVector}</code>: Abstract matrix <code>(sims × steps)</code> of <code>SVector</code> excess returns.</li><li><code>future_policies::Vector{Vector{Any}}</code>: A nested vector of interpolated policies for future time steps.</li><li><code>forced_policy_at_t_start</code>: Optional portfolio weight(s) to strictly apply at <code>t_start_idx</code>.   Can be a single <code>SVector</code> or a <code>Vector</code> of <code>SVector</code>s.</li><li><code>recorder::AbstractPathRecorder</code>: A logging mechanism to record the simulated wealth paths (defaults to <code>NoOpPathRecorder()</code>).</li></ul><p><strong>Returns</strong></p><ul><li>A tuple <code>(W_t_plus_1, W_T)</code>:<ul><li><code>W_t_plus_1::Vector{Float64}</code>: Wealth at the immediate next time step (<code>t_start_idx + 1</code>). This is captured and returned because it acts as the base expansion point in the denominator of the Brandt equation.</li><li><code>W_T::Vector{Float64}</code>: Terminal wealth at <code>T_end_idx</code>.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sliemelela/BrandtSolver.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BrandtSolver.solve_2nd_order_policy-Tuple{Dict{Vector{Int64}, Vector{Float64}}, Float64, Int64}"><a class="docstring-binding" href="#BrandtSolver.solve_2nd_order_policy-Tuple{Dict{Vector{Int64}, Vector{Float64}}, Float64, Int64}"><code>BrandtSolver.solve_2nd_order_policy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solve_2nd_order_policy(expected_moments_i, W_t, N_assets)</code></pre><p>Solves for the optimal portfolio weights using a 2nd-order Taylor expansion of the value function.</p><p>By truncating at the second order, the First Order Conditions (FOCs) reduce to a standard system of linear equations. A dynamic regularization term (jitter) is automatically scaled and added to the diagonal of the covariance-like matrix <code>B_mat</code> to guarantee numerical stability and invertibility, especially when dealing with nearly perfectly correlated assets or zero-variance states.</p><p><strong>Arguments</strong></p><ul><li><code>expected_moments_i::Dict{Vector{Int}, Vector{Float64}}</code>: A dictionary mapping the cross-asset   monomial exponent vectors to their conditionally expected values for a specific simulation path.</li><li><code>W_t::Float64</code>: The agent&#39;s specific wealth level at the current decision time.</li><li><code>N_assets::Int</code>: The total number of tradable risky assets in the market.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: The optimal allocation weights for the risky assets.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sliemelela/BrandtSolver.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BrandtSolver.solve_higher_order_policy-Tuple{Dict{Vector{Int64}, Vector{Float64}}, Float64, Int64, Int64}"><a class="docstring-binding" href="#BrandtSolver.solve_higher_order_policy-Tuple{Dict{Vector{Int64}, Vector{Float64}}, Float64, Int64, Int64}"><code>BrandtSolver.solve_higher_order_policy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solve_higher_order_policy(expected_moments_i, W_t, N_assets, max_taylor_order)</code></pre><p>Solves for the optimal portfolio weights using an arbitrary <code>max_taylor_order</code> expansion of the FOC.</p><p>If <code>max_taylor_order == 2</code>, it bypasses the non-linear solver entirely and efficiently returns the analytical linear solution via <code>solve_2nd_order_policy</code>. For orders strictly greater than 2, it dynamically generates the non-linear First Order Conditions (FOCs) using <code>multiexponents</code> and solves for the roots using <code>NonlinearSolve.jl</code>.</p><p>The analytical 2nd-order solution is injected as the initial guess to ensure rapid and stable convergence of the non-linear solver.</p><p><strong>Arguments</strong></p><ul><li><code>expected_moments_i::Dict{Vector{Int}, Vector{Float64}}</code>: A dictionary mapping the cross-asset   monomial exponent vectors to their conditionally expected values for a specific simulation path.</li><li><code>W_t::Float64</code>: The agent&#39;s specific wealth level at the current decision time.</li><li><code>N_assets::Int</code>: The total number of tradable risky assets in the market.</li><li><code>max_taylor_order::Int</code>: The highest degree of the Taylor expansion to compute   (e.g., 4 computes up to the 4th-order expansion).</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: The optimal allocation weights for the risky assets.   If the non-linear solver fails to converge, the algorithm safely falls back to returning the   2nd-order analytical solution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sliemelela/BrandtSolver.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BrandtSolver.solve_portfolio_problem-Tuple{AbstractMatrix{&lt;:StaticArraysCore.SVector}, Vector{&lt;:AbstractMatrix{Float64}}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, SolverParams, UtilityFunctions}"><a class="docstring-binding" href="#BrandtSolver.solve_portfolio_problem-Tuple{AbstractMatrix{&lt;:StaticArraysCore.SVector}, Vector{&lt;:AbstractMatrix{Float64}}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, SolverParams, UtilityFunctions}"><code>BrandtSolver.solve_portfolio_problem</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solve_portfolio_problem(
    Re_all_paths::AbstractMatrix{&lt;:SVector},
    Z_all_paths::Vector{&lt;:AbstractMatrix{Float64}},
    X_all_paths::AbstractMatrix{Float64},
    Y_all_paths::AbstractMatrix{Float64},
    solver_params::SolverParams,
    utility::UtilityFunctions;
    recorder::AbstractSolverRecorder = NoOpRecorder()
)</code></pre><p>The primary entry point for solving the dynamic portfolio choice problem.</p><p>It orchestrates the backward recursion (dynamic programming) by iterating backwards from the period before terminal time, <code>T-1</code>, to period <code>1</code>. At each step, it calculates the optimal policies conditionally based on the optimal <code>future_policies</code> derived in the previous iterations.</p><p><strong>Arguments</strong></p><ul><li><code>Re_all_paths::AbstractMatrix{&lt;:SVector}</code>: A matrix <code>(sims × steps)</code> of <code>SVector</code>s representing excess returns.</li><li><code>Z_all_paths::Vector{&lt;:AbstractMatrix{Float64}}</code>: A vector containing the state variable matrices.</li><li><code>X_all_paths::AbstractMatrix{Float64}</code>: The base gross risk-free return matrix.</li><li><code>Y_all_paths::AbstractMatrix{Float64}</code>: The non-tradable income return matrix.</li><li><code>solver_params::SolverParams</code>: Configuration parameters (e.g., <code>W_grid</code>, polynomial orders).</li><li><code>utility::UtilityFunctions</code>: The configured utility and derivatives functions.</li><li><code>recorder::AbstractSolverRecorder</code>: An optional recorder to log intermediate steps (defaults to <code>NoOpRecorder()</code>).</li></ul><p><strong>Returns</strong></p><ul><li><code>future_policies</code>: A nested vector structure <code>[time_step][simulation_path](Wealth)</code> that holds   the full interpolated policy rules for every path at every time step.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sliemelela/BrandtSolver.jl">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../architecture/">« Internal Architecture</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Saturday 21 February 2026 15:58">Saturday 21 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
