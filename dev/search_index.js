var documenterSearchIndex = {"docs":
[{"location":"api/#Test","page":"API Reference","title":"Test","text":"","category":"section"},{"location":"api/#BrandtSolver.AssetSV","page":"API Reference","title":"BrandtSolver.AssetSV","text":"Static Vector of size (N,) representing N assets.\n\n\n\n\n\n","category":"type"},{"location":"api/#BrandtSolver.AssetVec","page":"API Reference","title":"BrandtSolver.AssetVec","text":"Vector of size (N,) representing values across N assets.\n\n\n\n\n\n","category":"type"},{"location":"api/#BrandtSolver.RegressionStrategy","page":"API Reference","title":"BrandtSolver.RegressionStrategy","text":"Abstract parent type for all regression strategies.\n\n\n\n\n\n","category":"type"},{"location":"api/#BrandtSolver.SimAssetMat","page":"API Reference","title":"BrandtSolver.SimAssetMat","text":"Matrix of size (sim x N) representing asset values for each simulation.\n\n\n\n\n\n","category":"type"},{"location":"api/#BrandtSolver.SimTimeMat","page":"API Reference","title":"BrandtSolver.SimTimeMat","text":"Matrix of size (sim x Time) representing scalar values over time for each simulation.\n\n\n\n\n\n","category":"type"},{"location":"api/#BrandtSolver.SimTimeSV","page":"API Reference","title":"BrandtSolver.SimTimeSV","text":"Matrix of size (Sims x Time) where each entry is an AssetSV.\n\n\n\n\n\n","category":"type"},{"location":"api/#BrandtSolver.SimVec","page":"API Reference","title":"BrandtSolver.SimVec","text":"Vector of size (sim,) representing values across simulations.\n\n\n\n\n\n","category":"type"},{"location":"api/#BrandtSolver.SolverParams","page":"API Reference","title":"BrandtSolver.SolverParams","text":"struct SolverParams\n\nConfiguration parameters for the Brandt portfolio solver.\n\nArguments\n\nW_grid::Vector{Float64}: Grid of wealth values at initial time t=0 used to evaluate and interpolate the policy function.\npoly_order::Int64: Order of the polynomial used for expanding state variables in the cross-sectional regression.\nmax_taylor_order::Int64: The truncation order for the Taylor expansion of the value function.\ntrimming_α::Float64: The α value used if a trimmed regression strategy is applied.\n\n\n\n\n\n","category":"type"},{"location":"api/#BrandtSolver.StandardOLS","page":"API Reference","title":"BrandtSolver.StandardOLS","text":"Standard Ordinary Least Squares. Fastest method. Uses QR factorization.\n\n\n\n\n\n","category":"type"},{"location":"api/#BrandtSolver.TrimmedOLS","page":"API Reference","title":"BrandtSolver.TrimmedOLS","text":"Trimmed OLS (robust to outliers). Removes the top and bottom α probability mass before regressing.\n\nArguments\n\nα::Float64: The fraction of data to trim from both tails (e.g., 0.05 for 5% trimming).\n\n\n\n\n\n","category":"type"},{"location":"api/#BrandtSolver.UtilityFunctions","page":"API Reference","title":"BrandtSolver.UtilityFunctions","text":"struct UtilityFunctions\n\nA container for the utility function, its derivatives, and its inverse.\n\nArguments\n\nu::Function: The base utility function U(W).\nnth_derivative::Function: A function f(n) that returns a function for the n-th derivative of U(W).\ninverse::Function: The inverse utility function, used to calculate Certainty Equivalents.\n\nTypically, you do not construct this manually. Instead, use create_utility_from_ad to generate it automatically from a base utility function.\n\n\n\n\n\n","category":"type"},{"location":"api/#BrandtSolver.calculate_expected_utility-Tuple{AbstractMatrix{<:StaticArraysCore.SVector}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Vector{Vector{Any}}, Int64, Float64, Union{Vector{<:StaticArraysCore.SVector}, StaticArraysCore.SVector}, UtilityFunctions}","page":"API Reference","title":"BrandtSolver.calculate_expected_utility","text":"calculate_expected_utility(\n    Re_all_paths::AbstractMatrix{<:SVector},\n    X_all_paths::AbstractMatrix{Float64},\n    Y_all_paths::AbstractMatrix{Float64},\n    future_policies::Vector{Vector{Any}},\n    t_start::Int,\n    W_start::Float64,\n    ω_force::Union{Vector{<:SVector}, <:SVector},\n    utility_struct::UtilityFunctions\n)\n\nEvaluates the expected utility and Certainty Equivalent (CE) of a specific portfolio allocation (ω_force) at time t_start for a given starting wealth (W_start).\n\nIt calculates this by forward-simulating the wealth trajectories from t_start to terminal time T, assuming the agent applies the forced weights at t_start and then follows the optimal future_policies for all subsequent periods.\n\nPaths that result in bankruptcy (wealth leq 10^-9) are filtered out to prevent numerical explosion (e.g., utility approaching -infty for CRRA) before computing the final mean.\n\nArguments\n\nRe_all_paths::AbstractMatrix{<:SVector}: A matrix (sims × steps) of SVectors representing excess returns.\nX_all_paths::AbstractMatrix{Float64}: A matrix (sims × steps) of gross risk-free returns.\nY_all_paths::AbstractMatrix{Float64}: A matrix (sims × steps) of non-tradable income yields.\nfuture_policies::Vector{Vector{Any}}: A nested vector structure containing the   interpolated policy rules for t  t_start.\nt_start::Int: The time step from which to begin the forward simulation.\nW_start::Float64: The starting wealth level applied uniformly across all simulation paths.\nω_force::Union{Vector{<:SVector}, <:SVector}: The portfolio allocation to force at t_start.   Can be a single SVector (applied to all paths) or a Vector of SVectors (path-dependent weights).\nutility_struct::UtilityFunctions: The configured UtilityFunctions containing the base   utility u and its inverse.\n\nReturns\n\nA tuple (J_0, CE_0):\nJ_0::Float64: The conditionally expected utility across all valid, non-bankrupt simulated paths.\nCE_0::Float64: The Certainty Equivalent of that expected utility (the guaranteed, risk-free wealth level that yields identical utility).\n\n\n\n\n\n","category":"method"},{"location":"api/#BrandtSolver.calculate_next_wealth-NTuple{4, Any}","page":"API Reference","title":"BrandtSolver.calculate_next_wealth","text":" calculate_next_wealth(W_current, ω_t, Re_next, R_free)\n\nThe core physics kernel that advances wealth...\n\nArguments\n\nW_current: The wealth at time t.\nω_t: The chosen portfolio weight(s) for the risky assets at time t.\nRe_next: The realized excess return(s) of the risky assets at time t+1.\nR_free: The gross risk-free return between t and t+1.\n\n\n\n\n\n","category":"method"},{"location":"api/#BrandtSolver.calculate_realized_term-Tuple{Int64, Vector{Int64}, Vector{Float64}, Vector{Float64}, AbstractVector{<:StaticArraysCore.SVector}, UtilityFunctions}","page":"API Reference","title":"BrandtSolver.calculate_realized_term","text":"calculate_realized_term(\n    n::Int,\n    k_vec::Vector{Int},\n    W_t_plus_1::Vector{Float64},\n    W_T::Vector{Float64},\n    Re_next_svec::AbstractVector{<:SVector},\n    utility::UtilityFunctions,\n)\n\nComputes the realized marginal utility integrand (Y_n) for the n-th order term of the Taylor-expanded equation across all simulation paths.\n\nThe realized integrand for the Taylor expansion evaluates to: math     Y_n = U^{(n)}(W_T) \\left(\\frac{W_T}{W_{t+1}}\\right)^n \\left(\\prod_{j=1}^{N} R_{e, j, t+1}^{k_j}\\right) R_{e, t+1}`\n\nArguments\n\nn::Int: The specific derivative order in the Taylor expansion (e.g., 2 for the variance term).\nk_vec::Vector{Int}: A vector of integers representing the cross-asset monomial exponents k_j for the multivariate expansion.\nW_t_plus_1::Vector{Float64}: Simulated wealth at time t+1.\nW_T::Vector{Float64}: Simulated terminal wealth at time T.\nRe_next_svec::AbstractVector{<:SVector}: A vector of SVector excess returns at time t+1.\nutility::UtilityFunctions: The UtilityFunctions struct containing the n-th derivative generator.\n\nReturns\n\nA Matrix{Float64} of size (sims × N_assets) containing the evaluated integrand for each simulation path and each asset.\n\n\n\n\n\n","category":"method"},{"location":"api/#BrandtSolver.compute_and_regress_moments-Tuple{Int64, Int64, Int64, Vector{<:AbstractMatrix{Float64}}, Vector{Float64}, Vector{Float64}, AbstractVector{<:StaticArraysCore.SVector}, UtilityFunctions, BrandtSolver.RegressionStrategy}","page":"API Reference","title":"BrandtSolver.compute_and_regress_moments","text":"compute_and_regress_moments(t_decision, poly_order, max_taylor_order, Z_all_paths, W_t_plus_1,\n    W_T, Re_next_svec, utility, reg_strategy)\n\nOrchestrates the calculation of conditionally expected marginal utility moments for the Taylor-expanded equation.\n\nFor each term in the Taylor expansion up to max_taylor_order and for all cross-asset combinations (generated via multiexponents), this function calculates the realized ex-post integrand and then projects it onto the space of available information at t_decision using a cross-sectional regression.\n\nArguments\n\nt_decision::Int: The current time step in the backward recursion.\npoly_order::Int: The polynomial degree used to construct the basis functions (design matrix) from the state variables.\nmax_taylor_order::Int: The highest order of the Taylor expansion to compute.\nZ_all_paths::Vector{<:AbstractMatrix{Float64}}: A vector containing the full simulated paths of all state variables.\nW_t_plus_1::Vector{Float64}: The simulated wealth across all paths at time t+1.\nW_T::Vector{Float64}: The simulated terminal wealth across all paths at time T.\nRe_next_svec::AbstractVector{<:SVector}: A vector of SVectors representing realized excess returns at time t+1.\nutility::UtilityFunctions: The configured utility container with automatic differentiation.\nreg_strategy::RegressionStrategy: The chosen regression strategy (e.g., StandardOLS or TrimmedOLS).\n\nReturns\n\nDict{Vector{Int}, Matrix{Float64}}: A dictionary mapping the cross-asset monomial exponent   vectors (k_vec) to their conditionally expected values (a sims × N_assets matrix).\n\n\n\n\n\n","category":"method"},{"location":"api/#BrandtSolver.compute_conditional_expectation-Tuple{Int64, BrandtSolver.RegressionStrategy, Any, Union{Nothing, AbstractMatrix{Float64}}, Matrix{Float64}}","page":"API Reference","title":"BrandtSolver.compute_conditional_expectation","text":"compute_conditional_expectation(t_decision, reg_strategy, reg_context, φ, integrand)\n\nPerforms the cross-sectional regression to map realized future quantities to present expectations, conditional on current state variables.\n\nAt t  1, it uses the pre-computed regression context (e.g., a QR factorization) to rapidly project the realized integrand onto the basis matrix φ. At t = 1, since all agents share the exact same starting state, the conditional expectation is mathematically identical to the unconditional cross-sectional mean.\n\nArguments\n\nt_decision::Int: The current time step.\nreg_strategy::RegressionStrategy: The specific algorithm used to estimate coefficients.\nreg_context::Any: The pre-computed regression context   (e.g., a Factorization object for StandardOLS or a raw matrix for TrimmedOLS).\nφ::Union{Nothing, AbstractMatrix{Float64}}: The polynomial expansion of the state variables   (design matrix). Will be nothing at t = 1.\nintegrand::Matrix{Float64}: The realized future values (Y_n) to be projected onto the state space.\n\nReturns\n\nMatrix{Float64}: The predicted (conditionally expected) values for each simulation path and each asset.\n\n\n\n\n\n","category":"method"},{"location":"api/#BrandtSolver.compute_expectations_and_policy-Tuple{Int64, Int64, Int64, Float64, Vector{<:AbstractMatrix{Float64}}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{<:StaticArraysCore.SVector}, Int64, UtilityFunctions, Vector, BrandtSolver.RegressionStrategy}","page":"API Reference","title":"BrandtSolver.compute_expectations_and_policy","text":"compute_expectations_and_policy(\n    t_decision::Int,\n    poly_order::Int,\n    max_taylor_order::Int,\n    W_at_t::Float64,\n    Z_all_paths::Vector{<:AbstractMatrix{Float64}},\n    R_free_base::AbstractMatrix{Float64},\n    income_component::AbstractMatrix{Float64},\n    Re_all_paths::AbstractMatrix{<:SVector},\n    T_steps::Int,\n    utility::UtilityFunctions,\n    future_policies::Vector,\n    reg_strategy::RegressionStrategy,\n)\n\nCalculates the conditional expectations of utility moments and solves the First Order Conditions (FOCs) for the optimal portfolio weights across all simulation paths at a specific decision time and a single starting wealth level.\n\nArguments\n\nt_decision::Int: The current time step in the backward recursion.\npoly_order::Int: The polynomial degree for the cross-sectional regression basis.\nmax_taylor_order::Int: The Taylor expansion order of the value function.\nW_at_t::Float64: The specific wealth level being evaluated across all paths.\nZ_all_paths::Vector{<:AbstractMatrix{Float64}}: A vector of matrices representing the state variables.\nR_free_base::AbstractMatrix{Float64}: A matrix of gross risk-free returns.\nincome_component::AbstractMatrix{Float64}: A matrix of the non-tradable income yields.\nRe_all_paths::AbstractMatrix{<:SVector}: A matrix of SVector excess returns for the risky assets.\nT_steps::Int: The total number of simulation time steps.\nutility::UtilityFunctions: The utility struct containing u and its derivatives.\nfuture_policies::Vector: The optimal policy interpolators for time periods t > t_decision.\nreg_strategy::RegressionStrategy: The OLS strategy (Standard or Trimmed).\n\nReturns\n\nω_t_svec: A vector of SVectors containing the optimal weights for each simulation path.\nexpected_moments_all: A dictionary mapping exponent vectors to their conditionally expected matrices.\nW_t_plus_1: The simulated wealth at the next time step.\nW_T: The simulated terminal wealth.\n\n\n\n\n\n","category":"method"},{"location":"api/#BrandtSolver.create_policy_interpolators-Tuple{Int64, Vector{Float64}, Int64, Vector{<:AbstractMatrix{Float64}}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{<:StaticArraysCore.SVector}, Int64, UtilityFunctions, Vector{Vector{Any}}, Int64, BrandtSolver.RegressionStrategy, BrandtSolver.AbstractSolverRecorder}","page":"API Reference","title":"BrandtSolver.create_policy_interpolators","text":"create_policy_interpolators(\n    t_decision::Int,\n    W_grid::Vector{Float64},\n    poly_order::Int,\n    Z_all_paths::Vector{<:AbstractMatrix{Float64}},\n    R_free_base::AbstractMatrix{Float64},\n    income_component::AbstractMatrix{Float64},\n    Re_all_paths::AbstractMatrix{<:SVector},\n    T_steps::Int,\n    utility::UtilityFunctions,\n    future_policies::Vector{Vector{Any}},\n    max_taylor_order::Int,\n    reg_strategy::RegressionStrategy,\n    recorder::AbstractSolverRecorder\n)\n\nConstructs state-contingent policy rules for a given decision time by evaluating optimal portfolio weights across a specified grid of wealth values (W_grid) and interpolating the results.\n\nArguments\n\nt_decision::Int: Current time step in the backward recursion.\nW_grid::Vector{Float64}: The grid of wealth values to evaluate.\npoly_order::Int: Polynomial degree for the cross-sectional regression.\nZ_all_paths::Vector{<:AbstractMatrix{Float64}}: Vector of state variable matrices.\nR_free_base::AbstractMatrix{Float64}: Gross risk-free return matrix.\nincome_component::AbstractMatrix{Float64}: Non-tradable income matrix.\nRe_all_paths::AbstractMatrix{<:SVector}: Matrix of SVector excess returns.\nT_steps::Int: Total number of time steps.\nutility::UtilityFunctions: The UtilityFunctions struct.\nfuture_policies::Vector{Vector{Any}}: A vector of previously computed future policies.\nmax_taylor_order::Int: Expansion order for the Euler equation.\nreg_strategy::RegressionStrategy: The OLS strategy (Standard or Trimmed).\nrecorder::AbstractSolverRecorder: The logging mechanism for debugging data.\n\nReturns\n\nA Vector of linear interpolation objects (one for each simulation path).   Each interpolator takes a wealth value W and returns the optimal portfolio allocation vector ω.\n\n\n\n\n\n","category":"method"},{"location":"api/#BrandtSolver.create_utility_from_ad-Tuple{Function}","page":"API Reference","title":"BrandtSolver.create_utility_from_ad","text":"create_utility_from_ad(base_utility_func::Function)\n\nWraps a user-provided base utility function into a UtilityFunctions struct, automatically generating its exact higher-order derivatives and an inverse function.\n\nDetails\n\nDerivatives: Uses ForwardDiff.derivative recursively to compute any n-th order derivative.   Results are aggressively cached in a closure dictionary so that re-evaluating the same   derivative order carries zero compilation or setup overhead.\nInverse: Generates an inverse utility function W = U^-1(J) using Newton's method   (Roots.find_zero), relying on the automatically computed first derivative for fast convergence.\n\nArguments\n\nbase_utility_func::Function: A standard scalar function representing utility,   e.g., W mapsto fracW^1-γ1-γ\n\nReturns\n\nA populated UtilityFunctions struct.\n\n\n\n\n\n","category":"method"},{"location":"api/#BrandtSolver.estimate_coefficients-Tuple{StandardOLS, LinearAlgebra.Factorization, AbstractVector{Float64}}","page":"API Reference","title":"BrandtSolver.estimate_coefficients","text":"estimate_coefficients(::StandardOLS, qrΦ::Factorization, Y::AbstractVector{Float64})\n\nEstimates regression coefficients using Standard Ordinary Least Squares (OLS).\n\nThis method dispatches on the StandardOLS strategy type. It utilizes a pre-computed QR factorization (qrΦ) for maximum performance, avoiding the need to re-factorize the design matrix at every step.\n\nArguments\n\n::StandardOLS: The strategy selector. The variable name is omitted (anonymous argument) because the struct contains no data needed for the calculation.\nqrΦ::Factorization: The QR factorization of the design matrix Φ (from qr(Φ)).\nY::AbstractVector{Float64}: The dependent variable (response vector).\n\nReturns\n\nVector{Float64}: The estimated coefficients θ minimizing ||Φθ - Y||².\n\n\n\n\n\n","category":"method"},{"location":"api/#BrandtSolver.estimate_coefficients-Tuple{TrimmedOLS, AbstractMatrix, AbstractVector{Float64}}","page":"API Reference","title":"BrandtSolver.estimate_coefficients","text":"estimate_coefficients(strat::TrimmedOLS, Φ::AbstractMatrix, Y::AbstractVector{Float64})\n\nEstimates regression coefficients using α-Trimmed OLS (Least Trimmed Squares).\n\nThis method dispatches on the TrimmedOLS strategy. It is designed to be robust against outliers (e.g., extreme wealth paths in long-horizon simulations) by physically removing the top and bottom α fraction of the data distribution before regressing.\n\nArguments\n\nstrategy::TrimmedOLS: The strategy struct containing the trimming parameter strat.alpha.\nΦ::AbstractMatrix: The raw design matrix. Note: Unlike Standard OLS, we cannot use a pre-computed QR factorization because the rows included in the regression change dynamically based on the sorting of Y.\nY::AbstractVector{Float64}: The dependent variable (response vector).\n\nAlgorithm\n\nCalculates integer indices corresponding to the α and 1-α quantiles.\nSorts Y to identify the \"body\" of the distribution.\nSubsets both Y and Φ to exclude the extreme tails.\nSolves standard OLS on the remaining subset.\n\nReturns\n\nVector{Float64}: The estimated coefficients θ based on the trimmed dataset.\n\n\n\n\n\n","category":"method"},{"location":"api/#BrandtSolver.plot_policy_rules-NTuple{4, Any}","page":"API Reference","title":"BrandtSolver.plot_policy_rules","text":"plot_policy_rules(future_policies, solver_params, t_idx, asset_names; samples=50)\n\nPlots the optimal portfolio allocation (weights) as a function of wealth (W) for a specific decision time t_idx.\n\nIt plots a subset of individual simulation paths to show cross-sectional dispersion (due to varying state variables) and overlays a thick red line representing the mean policy across all simulations.\n\nArguments\n\nfuture_policies: The nested vector of interpolated policy functions returned by the solver.\nsolver_params: The configuration parameters, specifically used to extract the W_grid.\nt_idx: The decision time step to evaluate.\nasset_names: A list of strings representing the asset names, used to generate subplots.\nsamples: (Keyword) The number of individual simulation paths to plot as semi-transparent lines   (defaults to 50).\n\nReturns\n\nA Makie.Figure object containing the generated plot.\n\n\n\n\n\n","category":"method"},{"location":"api/#BrandtSolver.plot_policy_surface-Tuple{Any, Any, Any, AbstractVector, String, Any}","page":"API Reference","title":"BrandtSolver.plot_policy_surface","text":"plot_policy_surface(future_policies, solver_params, t_idx, state_values::AbstractVector, state_name::String, asset_names)\n\nGenerates a 3D surface plot visualizing the optimal portfolio weight as a joint function of both Wealth (W) and a specific state variable at decision time t_idx.\n\nThis provides a comprehensive view of the agent's full policy rule, showing how intertemporal hedging demands (driven by the state variable) interact with risk aversion (driven by wealth).\n\nArguments\n\nfuture_policies: The nested vector of interpolated policy functions.\nsolver_params: The configuration parameters used to extract W_grid.\nt_idx: The decision time step to evaluate.\nstate_values: A vector containing the cross-sectional values of the state variable at t_idx.\nstate_name: A string label for the state variable used for the y-axis.\nasset_names: A list of strings representing the asset names.\n\nReturns\n\nA Makie.Figure object containing the generated 3D surface plot.\n\n\n\n\n\n","category":"method"},{"location":"api/#BrandtSolver.plot_realized_weights-NTuple{6, Any}","page":"API Reference","title":"BrandtSolver.plot_realized_weights","text":" plot_realized_weights(Re_all_paths, X_all_paths, Y_all_paths, times, future_policies,\n    asset_names; W_init=100.0)\n\nSimulates wealth paths forward in time using the computed optimal future_policies and plots the realized trajectories of the portfolio weights over the lifecycle.\n\nIt overlays the mean realized weight and a 90% confidence interval band. Paths where wealth falls to zero (bankruptcy) are dynamically filtered out.\n\nArguments\n\nRe_all_paths: A matrix (sims × steps) of SVectors representing excess returns.\nX_all_paths: A matrix (sims × steps) of gross risk-free returns.\nY_all_paths: A matrix (sims × steps) of non-tradable income yields.\ntimes: An iterable of time points corresponding to the decision steps.\nfuture_policies: The nested vector of interpolated policy functions.\nasset_names: A list of strings representing the asset names.\nW_init: (Keyword) The initial wealth to start the forward simulation (defaults to 100.0).\n\nReturns\n\nA Makie.Figure object containing the generated plot.\n\n\n\n\n\n","category":"method"},{"location":"api/#BrandtSolver.plot_state_dependence-Tuple{Any, Any, Any, AbstractVector, String, Any}","page":"API Reference","title":"BrandtSolver.plot_state_dependence","text":"plot_state_dependence(future_policies, solver_params, t_idx, state_values::AbstractVector,\n    state_name::String, asset_names; fix_W=100.0)\n\nPlots the sensitivity of the optimal portfolio weights to a specific state variable (e.g., interest rate or dividend yield), holding wealth strictly constant at fix_W.\n\nArguments\n\nfuture_policies: The nested vector of interpolated policy functions.\nsolver_params: The configuration parameters.\nt_idx: The decision time step to evaluate.\nstate_values: A vector containing the cross-sectional values of the state variable at t_idx.\nstate_name: A string label for the state variable used for the x-axis.\nasset_names: A list of strings representing the asset names.\nfix_W: (Keyword) The constant wealth level at which to evaluate the policy (defaults to 100.0).\n\nReturns\n\nA Makie.Figure object containing the generated plot.\n\n\n\n\n\n","category":"method"},{"location":"api/#BrandtSolver.plot_value_vs_utility-NTuple{6, Any}","page":"API Reference","title":"BrandtSolver.plot_value_vs_utility","text":"plot_value_vs_utility(Re_all_paths, X_all_paths, Y_all_paths, solver_params, future_policies,\n    utility_struct; t_check=nothing)\n\nServes as an economic validity check by plotting the forward-simulated expected utility (the Value function, J(W)) against the theoretical terminal utility function U(W).\n\nIf the solver is working correctly, the expected utility J(W) evaluated at T - 1 should be equal to U(W), representing the value added by optimal dynamic trading.\n\nArguments\n\nRe_all_paths: A matrix of SVectors representing excess returns.\nX_all_paths: A matrix of gross risk-free returns.\nY_all_paths: A matrix of non-tradable income yields.\nsolver_params: The configuration parameters used to extract W_grid.\nfuture_policies: The nested vector of interpolated policy functions.\nutility_struct: The utility container.\nt_check: (Keyword) The specific time step to evaluate. Defaults to T-1.\n\nReturns\n\nA Makie.Figure object containing the generated plot.\n\n\n\n\n\n","category":"method"},{"location":"api/#BrandtSolver.power_matrix-Tuple{Vector{Vector{Float64}}, Int64}","page":"API Reference","title":"BrandtSolver.power_matrix","text":"power_matrix(Z::Vector{Vector{Float64}}, p::Int)\n\nConstructs a design matrix (feature matrix) for a polynomial regression model.\n\nIt generates power terms (e.g., x, x^2, ..., x^p) for each predictor variable in Z and prepends a column of ones to serve as the intercept term.\n\nThe final column order is: [intercept, Z[1]^1, Z[1]^2, ..., Z[1]^p, Z[2]^1, Z[2]^2, ..., Z[2]^p, ...]\n\nArguments\n\nZ::Vector{Vector{Float64}}: A vector of predictor variables. n = length(Z) is the number of distinct predictor variables, and sim = length(Z[1]) is the number of observations (rows). All inner vectors must have the same length.\np::Int: The maximum polynomial degree to compute for each predictor.\n\nReturns\n\nMatrix{Float64}: A design matrix of size sim × (n*p + 1).\n\nExamples\n\njulia> X1 = [1.0, 2.0, 3.0];\n\njulia> X2 = [4.0, 5.0, 6.0];\n\njulia> Z = [X1, X2]; # n=2 predictors, sim=3 observations\n\njulia> p = 2; # Max degree\n\njulia> BrandtSolver.power_matrix(Z, p)\n3×5 Matrix{Float64}:\n 1.0  1.0  1.0  4.0  16.0\n 1.0  2.0  4.0  5.0  25.0\n 1.0  3.0  9.0  6.0  36.0\n\n\n\n\n\n","category":"method"},{"location":"api/#BrandtSolver.record_step!-Tuple{DebugRecorder, Int64, Int64, Symbol, Any}","page":"API Reference","title":"BrandtSolver.record_step!","text":"record_step!(recorder, t, w_idx, label, value)\n\nHooks into the solver to save data.\n\n\n\n\n\n","category":"method"},{"location":"api/#BrandtSolver.simulate_wealth_trajectory-Tuple{Vector{Float64}, Int64, Int64, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{<:StaticArraysCore.SVector}, Vector{Vector{Any}}}","page":"API Reference","title":"BrandtSolver.simulate_wealth_trajectory","text":"simulate_wealth_trajectory(\n    W_start_vec::Vector{Float64},\n    t_start_idx::Int,\n    T_end_idx::Int,\n    X_full::AbstractMatrix{Float64},\n    Y_full::AbstractMatrix{Float64},\n    Re_full::AbstractMatrix{<:SVector},\n    future_policies::Vector{Vector{Any}};\n    forced_policy_at_t_start=nothing,\n    recorder::AbstractPathRecorder = NoOpPathRecorder()\n)\n\nSimulates wealth trajectories forward in time across all simulation paths from t_start_idx to T_end_idx.\n\nAt each time step, the function determines the portfolio weights (either using forced_policy_at_t_start for the initial step or querying the interpolated future_policies for subsequent steps). It then advances wealth using the calculate_next_wealth physics kernel.\n\nArguments\n\nW_start_vec::Vector{Float64}: Initial wealth values for all simulation paths at t_start_idx.\nt_start_idx::Int: The starting time step index.\nT_end_idx::Int: The terminal time step index.\nX_full::AbstractMatrix{Float64}: Abstract matrix (sims × steps) of gross risk-free returns.\nY_full::AbstractMatrix{Float64}: Abstract matrix (sims × steps) of non-tradable income yields.\nRe_full::AbstractMatrix{<:SVector}: Abstract matrix (sims × steps) of SVector excess returns.\nfuture_policies::Vector{Vector{Any}}: A nested vector of interpolated policies for future time steps.\nforced_policy_at_t_start: Optional portfolio weight(s) to strictly apply at t_start_idx.   Can be a single SVector or a Vector of SVectors.\nrecorder::AbstractPathRecorder: A logging mechanism to record the simulated wealth paths (defaults to NoOpPathRecorder()).\n\nReturns\n\nA tuple (W_t_plus_1, W_T):\nW_t_plus_1::Vector{Float64}: Wealth at the immediate next time step (t_start_idx + 1). This is captured and returned because it acts as the base expansion point in the denominator of the Brandt equation.\nW_T::Vector{Float64}: Terminal wealth at T_end_idx.\n\n\n\n\n\n","category":"method"},{"location":"api/#BrandtSolver.solve_2nd_order_policy-Tuple{Dict{Vector{Int64}, Vector{Float64}}, Float64, Int64}","page":"API Reference","title":"BrandtSolver.solve_2nd_order_policy","text":"solve_2nd_order_policy(expected_moments_i, W_t, N_assets)\n\nSolves for the optimal portfolio weights using a 2nd-order Taylor expansion of the value function.\n\nBy truncating at the second order, the First Order Conditions (FOCs) reduce to a standard system of linear equations. A dynamic regularization term (jitter) is automatically scaled and added to the diagonal of the covariance-like matrix B_mat to guarantee numerical stability and invertibility, especially when dealing with nearly perfectly correlated assets or zero-variance states.\n\nArguments\n\nexpected_moments_i::Dict{Vector{Int}, Vector{Float64}}: A dictionary mapping the cross-asset   monomial exponent vectors to their conditionally expected values for a specific simulation path.\nW_t::Float64: The agent's specific wealth level at the current decision time.\nN_assets::Int: The total number of tradable risky assets in the market.\n\nReturns\n\nVector{Float64}: The optimal allocation weights for the risky assets.\n\n\n\n\n\n","category":"method"},{"location":"api/#BrandtSolver.solve_higher_order_policy-Tuple{Dict{Vector{Int64}, Vector{Float64}}, Float64, Int64, Int64}","page":"API Reference","title":"BrandtSolver.solve_higher_order_policy","text":"solve_higher_order_policy(expected_moments_i, W_t, N_assets, max_taylor_order)\n\nSolves for the optimal portfolio weights using an arbitrary max_taylor_order expansion of the FOC.\n\nIf max_taylor_order == 2, it bypasses the non-linear solver entirely and efficiently returns the analytical linear solution via solve_2nd_order_policy. For orders strictly greater than 2, it dynamically generates the non-linear First Order Conditions (FOCs) using multiexponents and solves for the roots using NonlinearSolve.jl.\n\nThe analytical 2nd-order solution is injected as the initial guess to ensure rapid and stable convergence of the non-linear solver.\n\nArguments\n\nexpected_moments_i::Dict{Vector{Int}, Vector{Float64}}: A dictionary mapping the cross-asset   monomial exponent vectors to their conditionally expected values for a specific simulation path.\nW_t::Float64: The agent's specific wealth level at the current decision time.\nN_assets::Int: The total number of tradable risky assets in the market.\nmax_taylor_order::Int: The highest degree of the Taylor expansion to compute   (e.g., 4 computes up to the 4th-order expansion).\n\nReturns\n\nVector{Float64}: The optimal allocation weights for the risky assets.   If the non-linear solver fails to converge, the algorithm safely falls back to returning the   2nd-order analytical solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#BrandtSolver.solve_portfolio_problem-Tuple{AbstractMatrix{<:StaticArraysCore.SVector}, Vector{<:AbstractMatrix{Float64}}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, SolverParams, UtilityFunctions}","page":"API Reference","title":"BrandtSolver.solve_portfolio_problem","text":"solve_portfolio_problem(\n    Re_all_paths::AbstractMatrix{<:SVector},\n    Z_all_paths::Vector{<:AbstractMatrix{Float64}},\n    X_all_paths::AbstractMatrix{Float64},\n    Y_all_paths::AbstractMatrix{Float64},\n    solver_params::SolverParams,\n    utility::UtilityFunctions;\n    recorder::AbstractSolverRecorder = NoOpRecorder()\n)\n\nThe primary entry point for solving the dynamic portfolio choice problem.\n\nIt orchestrates the backward recursion (dynamic programming) by iterating backwards from the period before terminal time, T-1, to period 1. At each step, it calculates the optimal policies conditionally based on the optimal future_policies derived in the previous iterations.\n\nArguments\n\nRe_all_paths::AbstractMatrix{<:SVector}: A matrix (sims × steps) of SVectors representing excess returns.\nZ_all_paths::Vector{<:AbstractMatrix{Float64}}: A vector containing the state variable matrices.\nX_all_paths::AbstractMatrix{Float64}: The base gross risk-free return matrix.\nY_all_paths::AbstractMatrix{Float64}: The non-tradable income return matrix.\nsolver_params::SolverParams: Configuration parameters (e.g., W_grid, polynomial orders).\nutility::UtilityFunctions: The configured utility and derivatives functions.\nrecorder::AbstractSolverRecorder: An optional recorder to log intermediate steps (defaults to NoOpRecorder()).\n\nReturns\n\nfuture_policies: A nested vector structure [time_step][simulation_path](Wealth) that holds   the full interpolated policy rules for every path at every time step.\n\n\n\n\n\n","category":"method"},{"location":"architecture/#Internal-Architecture-and-Flow","page":"Internal Architecture","title":"Internal Architecture & Flow","text":"This section is written for developers, contributors, and future maintainers who want to understand how and why the codebase is structured the way it is.\n\nBrandtSolver.jl implements the simulation-based dynamic portfolio choice algorithm originally proposed by Brandt et al. (2005). The solver works backwards through time (Dynamic Programming) using cross-sectional regressions to approximate conditional expectations.","category":"section"},{"location":"architecture/#High-Level-Execution-Flow","page":"Internal Architecture","title":"High-Level Execution Flow","text":"The entire algorithm is orchestrated by solve_portfolio_problem. If we have a simulation with M decision steps (t_1 t_2 dots t_M), the algorithm flows like this:\n\nTime Loop (Backwards): Start at the last decision period t = M and walk backwards to t = 1.\nWealth Grid Loop: At the current time t, evaluate the optimal policy across a predefined grid of starting wealths (e.g., W in 50 100 150).\nFor each Wealth point, do the following:\nForward Simulation: Simulate the wealth paths forward from t to T. We assume a zero-weight allocation between t and t+1, and apply our already-computed optimal policies for all periods after t+1.\nEvaluate Realized Moments: Calculate the ex-post realized marginal utility components (the Taylor series terms) for all simulated paths.\nCross-Sectional Regression: Regress these realized future values onto the state variables at time t to obtain conditional expectations.\nRoot Finding (FOC): Using these conditional expectations, solve the First Order Conditions (Euler equation) to find the optimal portfolio weights omega_t.\nInterpolation: Once omega_t is found for every point on the wealth grid, fit a linear interpolator so we can continuously evaluate omega_t(W) for the next step backwards.\n\n","category":"section"},{"location":"architecture/#Module-Breakdown","page":"Internal Architecture","title":"Module Breakdown","text":"To keep the logic clean, the src/ directory is split into distinct files representing the different mathematical phases of the algorithm.","category":"section"},{"location":"architecture/#1.-orchestrator.jl-(The-Main-Loops)","page":"Internal Architecture","title":"1. orchestrator.jl (The Main Loops)","text":"This file contains the highest-level logic and manages the dynamic programming loops.\n\nsolve_portfolio_problem: The main entry point. Sets up the regression strategy and   handles the backwards time loop.\ncreate_policy_interpolators: Loops over the W_grid.   Once all weights are solved for the grid, it uses Interpolations.jl to build a strongly-typed   vector of policy interpolators.\ncompute_expectations_and_policy: The master function for a single time step and a   single wealth point. It calls the simulator, asks for the regressions, and passes the results   to the FOC optimizer.","category":"section"},{"location":"architecture/#2.-simulator.jl-(The-Physics)","page":"Internal Architecture","title":"2. simulator.jl (The Physics)","text":"This file handles forward-time mechanics. Because the solver works via dynamic programming, evaluating a decision at time t requires knowing the wealth outcomes at time t+1 and terminal time T.\n\nsimulate_wealth_trajectory: Takes a starting wealth vector and rolls it forward through   time using calculate_next_wealth. It applies the future_policies that were computed in   previous iterations of the backwards loop.\ncalculate_realized_term: Computes the actual, realized integrand Y_n for the n-th order   Taylor expansion term of the Euler equation. It evaluates the derivatives of the utility   function at the terminal wealth W_T.","category":"section"},{"location":"architecture/#3.-expectations.jl-(The-Regression-Logic)","page":"Internal Architecture","title":"3. expectations.jl (The Regression Logic)","text":"Because agents don't know the future, they must form expectations conditional on the information available today.\n\ncompute_and_regress_moments: Generates all possible cross-asset Taylor expansion terms   using multiexponents. It calculates the realized terms and passes them to the regression engine.\ncompute_conditional_expectation: Projects the realized future values onto the current state variables.   Uses either StandardOLS (fast QR factorization) or TrimmedOLS (robust filtering of explosive wealth paths).","category":"section"},{"location":"architecture/#4.-optimizer.jl-(The-Solver)","page":"Internal Architecture","title":"4. optimizer.jl (The Solver)","text":"Once the expected moments are calculated, the portfolio choice problem reduces to finding the roots of a polynomial system (the Taylor-expanded First Order Conditions).\n\nsolve_2nd_order_policy: If the Taylor expansion is exactly 2nd-order, the   FOC is a purely linear system (Aomega = b).   This function solves it analytically using matrix inversion, injecting a small jitter (λ * I) to   the diagonal to ensure the matrix remains invertible even with highly correlated assets.\nsolve_higher_order_policy: For 3rd-order or higher expansions, the FOC is highly non-linear.   This function uses NonlinearSolve.jl to find the roots. Crucially,   it calls solve_2nd_order_policy first and uses the analytical linear solution as the   initial guess, guaranteeing rapid convergence.","category":"section"},{"location":"architecture/#5.-utility.jl-and-types.jl-(Data-Structures)","page":"Internal Architecture","title":"5. utility.jl & types.jl (Data Structures)","text":"types.jl: Defines the SolverParams and RegressionStrategy structs.   It also holds the Recorder types used for cleanly logging internal solver data for   debugging and plotting without impacting performance.\nutility.jl: Contains create_utility_from_ad, which uses ForwardDiff.jl to automatically   generate and aggressively cache all higher-order derivatives of the user's utility function,   along with computing the inverse utility via Roots.jl.","category":"section"},{"location":"#BrandtSolver.jl","page":"Home","title":"BrandtSolver.jl","text":"","category":"section"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"}]
}
